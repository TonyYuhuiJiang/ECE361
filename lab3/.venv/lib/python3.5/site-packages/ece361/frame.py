#
# Copyright 2020 University of Toronto
#
# Permission is hereby granted, to use this software and associated
# documentation files (the "Software") in course work at the University
# of Toronto, or for personal use. Other uses are prohibited, in
# particular the distribution of the Software either publicly or to third
# parties.
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

import struct
import time
from enum import Enum

# data structure for encapsulating a frame
class Frame:
    class Status(Enum):
        notsent = 0,
        inflight = 1,
        timedout = 2,
        ack_nacked = 3

    def __init__(self, seqnum, data, ack=0, timeout=None):
        self.seqnum = seqnum
        self.data = data
        self.timeout = timeout
        self.ack = ack # ACK from sender to receiver, for keep alive purpose in this lab
        self.send_time = None
        self.ack_time = None
        self.length = len(data)
        self.status = Frame.Status.notsent
        self.retransmitted = False

    '''
    Get the packed frame
    '''
    def get_frame(self):
        return pack_data(self)

    '''
    Set the frame as sent: this will set the send_time as well
    '''
    def set_sent(self, t=None):
        if t is None:
            t = time.time()
        self.send_time = t
        if self.status == Frame.Status.inflight or self.status == Frame.Status.timedout:
            self.retransmitted = True
        self.status = Frame.Status.inflight

    '''
    Set the frame status to timedout
    '''
    def set_timeout(self):
        self.status = Frame.Status.timedout

    '''
    Check if the frame has timedout based on the the sent_time and the current time. If the frame's status is already timedout, then we return the status directly
    '''
    def has_timedout(self):
        if self.status == Frame.Status.inflight:
            curr_t = time.time()
            if curr_t - self.send_time > self.timeout:
                self.set_timeout()
                return True
        elif self.status == Frame.Status.timedout:
            return True
        
        return False

    '''
    Return the status of the frame
    '''
    def get_status(self):
        return self.status
        

def pack_data(frame):
    # pack sequence number and data together as a byte stream for transmission
    # the first 4 bytes is sequence number, followed by the actual data
    
    format = 'ii'
    data_len = len(frame.data)
    if data_len > 0:
        format = format + str(len(frame.data)) + 's'
        packed_data = struct.pack(format, frame.seqnum, frame.ack, frame.data)
    else:
        packed_data = struct.pack(format, frame.seqnum, frame.ack)
    return packed_data

def unpack_data(raw_data):
    # interpret byte sequence data as a Frame object. exactly the inverse of pack_data
    raw_data_length = len(raw_data) - struct.calcsize('ii')
    format = 'ii' + str(raw_data_length) + 's'
    ack, seqnum, data = struct.unpack(format, raw_data)
    return Frame(seqnum, data, ack=ack)
