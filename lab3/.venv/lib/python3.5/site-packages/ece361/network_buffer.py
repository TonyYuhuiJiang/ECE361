#
# Copyright 2020 University of Toronto
#
# Permission is hereby granted, to use this software and associated
# documentation files (the "Software") in course work at the University
# of Toronto, or for personal use. Other uses are prohibited, in
# particular the distribution of the Software either publicly or to third
# parties.
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

class NetworkBuffer():
    
    '''
    length: length of the buffer
    debug: debug flag to turn on/off debug logging
    '''
    def __init__(self, length, debug=False):
        self.Wr = length # buffer length, should be the same as the window size
        self.buffer = [None] * self.Wr # Pre allocate the buffer
        self.frame_idxs = {} # Index for fast lookup
        self.debug = debug
    
    '''
    Check if the provided index of the buffer is the start of a frame
    idx: The buffer index
    '''
    def is_start_of_frame(self, idx):
        if idx in self.frame_idxs:
            return True
        else:
            return False

    '''
    Return the buffer list
    '''
    def get_buffer(self):
        return self.buffer

    '''
    Check if a frame exist at the provided start position of the buffer (same as the is_start_of_frame)
    start_idx: The start buffer index of the frame
    '''
    def frame_exist(self, start_idx):
        return self.is_start_of_frame(start_idx)

    '''
    Get the frame from the buffer and remove it from the buffer
    start_idx: The start buffer index of the frame
    '''
    def pop_frame(self, start_idx):
        out = []
        if start_idx not in self.frame_idxs:
            return None
        for i in range(self.frame_idxs[start_idx]['length']):
            out.append(self.buffer[(start_idx+i) % self.Wr])
            self.buffer[(start_idx+i) % self.Wr] = None
        del self.frame_idxs[start_idx]
        if out != []:
            return bytes(out)
        else:
            return None
    '''
    Get the frame but keep the frame in the buffer
    start_idx: The start buffer index of the frame
    '''
    def get_frame(self, start_idx):
        out = []
        if start_idx not in self.frame_idxs:
            return None
        for i in range(self.frame_idxs[start_idx]['length']):
            out.append(self.buffer[(start_idx+i) % self.Wr])

        if out != []:
            return bytes(out)
        else:
            return None

    '''
    Get the frame length with start buffer index of the frame
    start_idx: The start buffer index of the frame
    '''
    def get_frame_length(self, start_idx):
        return self.get_frame_metadata(start_idx, 'length')

    '''
    Get the metadata related to the frame with start buffer index of the frame
    start_idx: The start buffer index of the frame
    '''
    def get_frame_metadata(self, start_idx, metadata_name):
        if start_idx not in self.frame_idxs:
            return None
        else:
            return self.frame_idxs[start_idx].get(metadata_name, None)

    '''
    Helper function: check if a frame is overwriting another frame
    idx: buffer index
    '''
    def _check_if_overwriting(self, idx):
        if self.buffer[idx] is not None:
            if self.debug:
                print("DEBUG - insert_frame - Network Buffer - overwriting bytes at index %s" % idx)
            return True
        else:
            return False
    
    '''
    Helper function: check if a frame can be inserted
    start_idx: The start buffer index to check
    data_size: length of the frame interested in inserting
    '''
    def _check_if_frame_can_insert(self, start_idx, data_size):
        if start_idx in self.frame_idxs:
            if self.debug:
                print("DEBUG - insert_frame - Network Buffer - duplicated frame detected at %s" % start_idx)
            return False
        for i in range(data_size):
            idx = (start_idx + i) % self.Wr
            if self._check_if_overwriting(idx):
                return False
        return True

    '''
    Insert frame
    start_idx: the start buffer index of the frame
    data: data to be inserted to the buffer (only the payload should be inserted)
    frame_metadata: any metadata you would like to store with this frame (e.g. sequence number, etc)
    @return: True if sucessful
    '''
    def insert_frame(self, start_idx, data, frame_metadata={}):
        data_size = len(data)
        metadata = {}
        if self._check_if_frame_can_insert(start_idx, data_size):
            for i in range(data_size):
                idx = (start_idx + i) % self.Wr
                self.buffer[idx] = data[i]
            metadata['length'] = data_size
            for key in frame_metadata:
                metadata[key] = frame_metadata[key]
            self.frame_idxs[start_idx] = metadata
            return True
        else:
            return False