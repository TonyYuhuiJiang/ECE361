#
# Copyright 2020 University of Toronto
#
# Permission is hereby granted, to use this software and associated
# documentation files (the "Software") in course work at the University
# of Toronto, or for personal use. Other uses are prohibited, in
# particular the distribution of the Software either publicly or to third
# parties.
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

import time 

class ApplicationProcess():
    def __init__(self, args):
        self.args = args
        self.APP_WAIT_TIME = args.application_wait_time #the period between application read from buffer, -1 mean no waiting
        self.APP_MAX_READ_BYTES = args.application_max_read_bytes # the number of bytes application can read each time, -1 mean no limit
        self.last_time = time.time()
        self.f = None

    '''
    Setup the application process
    '''
    def application_processing_setup(self):
        self.f = open(self.args.file, 'wb')


    '''
    process received data
    '''
    def process_data(self, data):
        self.f.write(data)
        self._flush_output()

    '''
    Close application
    '''
    def application_process_close(self):
        self.f.close()
        self.f = None


    '''
    Get data from receiver and process the received data
    '''
    def process(self, receiver):
        t_now = time.time()
        # Check if time to process
        if t_now - self.last_time > self.APP_WAIT_TIME or self.APP_WAIT_TIME < 0:
            max_bytes = self.APP_MAX_READ_BYTES if self.APP_MAX_READ_BYTES > 0 else None
            data = receiver.application_get_data(max_bytes)
            self.process_data(data)
            self.last_time = t_now


    '''
    Used for flushing data to the application
    '''
    def _flush_output(self):
        self.f.flush()

    def __del__(self):
        if self.f:
            self.f.close()

