#
# Copyright 2020 University of Toronto
#
# Permission is hereby granted, to use this software and associated
# documentation files (the "Software") in course work at the University
# of Toronto, or for personal use. Other uses are prohibited, in
# particular the distribution of the Software either publicly or to third
# parties.
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

import struct
import select
from enum import Enum
from .socket import Socket

# data structure for encapsulating a frame
class Frame:
    class Status(Enum):
        notsent = 0,
        inflight = 1,
        timedout = 2,
        ack_nacked = 3

    def __init__(self, seqnum, data, destination=None, expected_ack=None, timeout=None):
        self.seqnum = seqnum
        self.data = data
        self.expected_ack = expected_ack

        self.socket = Socket(destination,
                             # since the ack from the other side is just a sequence number with no data,
                             # we only need to receive an integer
                             recvfrom_bytes=struct.calcsize('i'),
                             timeout=timeout)

    def send(self):
        self.socket.sendto(self.pack_data())

    def wait_for_ack_nack(self):
        self.socket.recvfrom()

    def retrieve_ack_nack(self):
        assert self.status() == Frame.Status.ack_nacked, 'cannot call retrieve_ack_nack() when frame not in ack_nacked state!'
        return Frame.unpack_data(self.socket.msg_received['message'])

    def sendtime(self):
        return self.socket.t_send

    def acktime(self):
        return self.socket.t_ack

    def status(self):
        if (self.socket.msg_received == None):
            return Frame.Status.notsent
        elif (self.socket.msg_received == {}):
            # ack is empty which means frame is still in flight
            return Frame.Status.inflight
        elif (self.socket.msg_received['address'][0] == '127.0.0.1'):
            # message from localhost, which means timeout
            return Frame.Status.timedout
        else:
            # ack/nack received
            return Frame.Status.ack_nacked

    def pack_data(self):
        # pack sequence number and data together as a byte stream for transmission
        # the first 4 bytes is sequence number, followed by the actual data
        format = 'i' + str(len(self.data)) + 's'
        return struct.pack(format, self.seqnum, self.data)

    @classmethod
    def unpack_data(cls, raw_data):
        # interpret byte sequence data as a Frame object. exactly the inverse of pack_data
        raw_data_length = len(raw_data) - struct.calcsize('i')
        format = 'i' + str(raw_data_length) + 's'
        seqnum, data = struct.unpack(format, raw_data)
        return cls(seqnum, data)

    @staticmethod
    def wait_for_multiple_ack_nacks(frames_list):
        waiting_sockets = [frame.socket for frame in frames_list]
        readable, writable, exceptional = select.select(waiting_sockets, [], waiting_sockets)

        for s in readable:
            # retrieve ack/nack
            s.recvfrom()

        for s in exceptional:
            # should never be here
            print("socket exception")

    def __del__(self):
        self.socket.close()
