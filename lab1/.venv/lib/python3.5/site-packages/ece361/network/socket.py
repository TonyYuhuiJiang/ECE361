#
# Copyright 2020 University of Toronto
#
# Permission is hereby granted, to use this software and associated
# documentation files (the "Software") in course work at the University
# of Toronto, or for personal use. Other uses are prohibited, in
# particular the distribution of the Software either publicly or to third
# parties.
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
from ece361.network.chtx import Client as TX
from ece361.network.chrx import Client as RX
from random import randint
import _thread
import json
import time


class Socket:
    def __init__(self, student_number):
        ''' The src_name and src_id will be used as the source address in the header and can be changed later.'''
        self.src_address = ''
        self.src_port = ''
        self.sender_address = []
        self.source_address = {'src_address': '', 'src_port': ''}
        self.destination_address = {'dst_address': '', 'dst_port': ''}
        ''' The segment header that will be attached to every segments.'''
        self.header = {'source': self.source_address, 'destination': self.destination_address}
        ''' This in cludes the segment header and payload.'''
        self.segment = {'header': self.header, 'payload': ''}
        self.last_header = self.header
        self.last_segment = self.segment
        self.BROADCAST_ADDRESS = 'broadcast'
        ''' This is used to shadow dst_port when the dst_address is not Broadcast'''
        self.BROADCAST_PORT = 'N/A'
        ''' the id is used to setup channel tx/rx.'''
        self.tx = None
        self.rx = None
        ''' The method assign initial name and id to the src_name and src_id and setup the channel rx/tx interfaces.'''
        self.setup_client(student_number)
        ''' It starts the channel rx daemon.'''
        _thread.start_new_thread(self.rx.subscribe, ())

    ''' This method can be used to change the defualt name/id that socket uses for broadcasting messages.'''
    def set_broadcast_info(self, address, port):
        self.BROADCAST_ADDRESS = address
        self.BROADCAST_PORT = port

    ''' This method can be used to set the defualt ip address/port used by the channel to send/receive messages.'''
    def set_channel_address(self, address=None, port=None):
        self.tx.set_channel_address(address, port)
        self.rx.set_channel_address(address, port)

    ''' This method is used to initiate RX and TX interfaces.'''
    def setup_client(self, nonce):
        current_time = str(time.time()).split('.')
        self.src_address = current_time[0] + current_time[1]
        self.src_port = self.BROADCAST_PORT
        client_id = str(nonce) + '/' + self.src_address
        self.tx = TX(client_id)
        self.rx = RX(client_id)

    ''' This method can be used to change the socket src_address and src_port from their previous or defualt value.'''
    def change_source_address(self, address=None, port=None):
        if address:
            self.src_address = address
        if port:
            self.src_port = port

    ''' This method will send the application_data to a particular destination. The defualt behavior is to broadcast.'''
    def sendto(self, application_data, dst_address=None, dst_port=None):
        if len(application_data) <= 100:
            outgoing_segment = self.create_segment(application_data, dst_address, dst_port)
            self.tx.transfer_out(outgoing_segment)
            return len(application_data)
        else:
            ''' -1 indicates an error in sending data'''
            return -1

    ''' This method is used to receive the data from the channel. It can receive the messages destined to this socket 
    or broadcasted in the channel.'''
    def recvfrom(self):
        while True:
            ''' Reading the incoming packet from the queue.'''
            incoming_segment = self.rx.transfer_in()
            if incoming_segment != False:
                ''' Removing the segment payload from the message.'''
                data = incoming_segment['payload']
                self.sender_address = []
                if incoming_segment['header']['destination']['dst_address'] == self.BROADCAST_ADDRESS:
                    self.sender_address.append(incoming_segment['header']['source']['src_address'])
                    self.sender_address.append(incoming_segment['header']['source']['src_port'])
                    return self.sender_address, data
                elif incoming_segment['header']['destination']['dst_address'] == self.src_address:
                    if incoming_segment['header']['destination']['dst_port'] == self.src_port or \
                            incoming_segment['header']['destination']['dst_port'] == self.BROADCAST_PORT:
                        self.sender_address.append(incoming_segment['header']['source']['src_address'])
                        self.sender_address.append(incoming_segment['header']['source']['src_port'])
                        return self.sender_address, data

    ''' The method prepares the segment for transmission. JSON is used to create semi-structured messages. '''
    def create_segment(self, application_data, address=None, port=None):
        if address and port:
            self.destination_address['dst_address'] = address
            self.destination_address['dst_port'] = port
        elif address and (not port):
            self.destination_address['dst_address'] = address
            self.destination_address['dst_port'] = self.BROADCAST_PORT
        elif (not address) and (not port):
            self.destination_address['dst_address'] = self.BROADCAST_ADDRESS
            self.destination_address['dst_port'] = self.BROADCAST_PORT
        else:
            ''' -1 indicates an error in the destination address/port or the absence of application_data.'''
            return -1
        self.source_address['src_address'] = self.src_address
        self.source_address['src_port'] = self.src_port
        self.header['source'] = self.source_address
        self.header['destination'] = self.destination_address
        self.segment['payload'] = application_data
        self.last_header = self.header
        self.last_segment = self.segment
        return json.dumps(self.segment)

    ''' This method return the last header that was used to send data to the channel'''
    def display_last_header(self):
        print(self.last_header)

    ''' This method return the last segment that was sent to the channel'''
    def display_last_segment(self):
        print(self.last_segment)